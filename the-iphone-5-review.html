<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=description content="Section by Anand Shimpi All Computer Engineers at NCSU had to take mandatory programming courses. Given that my dad is a Computer Science professor, I always had exposure to programming, but I never considered it my strong suit - perhaps me gravitating towards hardware was some passive rebellious thing. Either way I knew that in"><meta name=author content="Aldo Pusey"><meta name=generator content="Hugo 0.98.0"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta name=robots content="index,follow,noarchive"><link rel=stylesheet href=https://assets.cdnweb.info/hugo/base16/css/style.css type=text/css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type=text/css><link rel=alternate href=./index.xml type=application/rss+xml title=JadeSync><title>Custom Code to Understand a Custom Core - JadeSync</title></head><body><header><div class="container clearfix"><a class=path href=./index.html>[JadeSync]</a>
<span class=caret># _</span><div class=right></div></div></header><div class=container><main role=main class=article><article class=single itemscope itemtype=http://schema.org/BlogPosting><div class=meta><span class=key>published on</span>
<span class=val><time itemprop=datePublished datetime=2024-07-21>July 21, 2024</time></span>
<span class=key>in</span>
<span class=val><a href=./categories/blog>blog</a></span></div><h1 class=headline itemprop=headline>Custom Code to Understand a Custom Core</h1><section class=body itemprop=articleBody><p>Section by Anand Shimpi</p><p>All Computer Engineers at NCSU had to take mandatory programming courses. Given that my dad is a Computer Science professor, I always had exposure to programming, but I never considered it my strong suit - perhaps me gravitating towards hardware was some passive rebellious thing. Either way I knew that in order to really understand Swift, I'd have to do some coding on my own. The only problem? I have zero experience writing Objective-C code for iOS, and not enough time to go through a crash course.</p><p>I had code that I wanted to time/execute in C, but I needed it ported to a format that I could easily run/monitor on an iPhone. I enlisted the help of a talented developer friend who graduated around the same time I did from NCSU, Nirdhar Khazanie. Nirdhar has been working on mobile development for years now, and he quickly made the garbled C code I wanted to run into something that executed beautifully on the iPhone. He gave me a framework where I could vary instructions as well as data set sizes, which made this next set of experiments possible. It's always helpful to know a good programmer.</p><p>So what did Nirdhar's app let me do? Let's start at the beginning. ARM's Cortex A9 has two independent integer ALUs, does Swift have more? To test this theory I created a loop of independent integer adds. The variables are all independent of one another, which should allow for some great instruction level parallelism. The code loops many times, which should make for some easily predictable branches. My code is hardly optimal but I did keep track of how many millions of adds were executed per second. I also reported how long each iteration of the loop took, on average.</p><table align=center border=0 cellpadding=0 cellspacing=1 width=575><tbody readability=5><tr class=tgrey><td align=center colspan=7>Integer Add Code</td></tr><tr class=tlblue readability=8><td width=120>&nbsp;</td><td align=center valign=middle width=85>Apple A5 (2 x Cortex A9 @ 800MHz</td><td align=center valign=middle width=85>Apple A5 Scaled (2 x Cortex A9 @ 1300MHz</td><td align=center valign=middle width=85>Apple A6 (2 x Swift @ 1300MHz</td><td align=center valign=middle width=85>Swift / A9 Perf Advantage @ 1300MHz</td></tr><tr><td class=tlgrey>Integer Add Test</td><td align=center valign=middle>207 MIPS</td><td align=center valign=middle>336 MIPS</td><td align=center valign=middle>369 MIPS</td><td align=center valign=middle>9.8%</td></tr><tr readability=2><td class=tlgrey>Integer Add Latency in Clocks</td><td align=center valign=middle>23 clocks</td><td align=center valign=middle>&nbsp;</td><td align=center valign=middle>21 clocks</td><td align=center valign=middle>&nbsp;</td></tr></tbody></table><p>The code here should be fairly bound by the integer execution path. We're showing a 9.8% increase in performance. Average latency is improved slightly by 2 clocks, but we're not seeing the sort of ILP increase that would come from having a third ALU that can easily be populated. The slight improvement in performance here could be due to a number of things. A quick look at some of Apple's own documentation confirms what we've seen here: Swift has two integer ALUs and can issue 3 operations per cycle (implying a 3-wide decoder as well). I don't know if the third decoder is responsible for the slight gains in performance here or not.</p><p align=center><img height=73 src=https://cdn.statically.io/img/images.anandtech.com/reviews/smartphones/apple/iPhone5/review/swift.jpg width=600 style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></p><p>What about floating point performance? ARM's Cortex A9 only has a single issue port for FP operations which seriously hampers FP performance. Here I modified the code from earlier to do a bunch of single and double precision FP multiplies:</p><table align=center border=0 cellpadding=0 cellspacing=1 width=575><tbody readability=6><tr class=tgrey><td align=center colspan=7>FP Add Code</td></tr><tr class=tlblue readability=8><td width=120>&nbsp;</td><td align=center valign=middle width=85>Apple A5 (2 x Cortex A9 @ 800MHz</td><td align=center valign=middle width=85>Apple A5 Scaled (2 x Cortex A9 @ 1300MHz</td><td align=center valign=middle width=85>Apple A6 (2 x Swift @ 1300MHz</td><td align=center valign=middle width=85>Swift / A9 Perf Advantage @ 1300MHz</td></tr><tr readability=2><td class=tlgrey>FP Mul Test (single precision)</td><td align=center valign=middle>94 MFLOPS</td><td align=center valign=middle>153 MFLOPS</td><td align=center valign=middle>143 MFLOPS</td><td align=center valign=middle>-7%</td></tr><tr readability=2><td class=tlgrey>FP Mul Test (double precision)</td><td align=center valign=middle>87 MFLOPS</td><td align=center valign=middle>141 MFLOPS</td><td align=center valign=middle>315 MFLOPS</td><td align=center valign=middle>123%</td></tr></tbody></table><p>There's actually a slight regression in performance if we look at single precision FP multiply performance, likely due to the fact that performance wouldn't scale perfectly linearly from 800MHz to 1.3GHz. Notice what happens when we double up the size of our FP multiplies though, performance goes up on Swift but remains unchanged on the Cortex A9. Given the support for ARM's VFPv4 extensions, Apple likely has a second FP unit in Swift that can help with FMAs or to improve double precision FP performance. It's also possible that Swift is a 128-bit wide NEON machine and my DP test compiles down to NEON code which enjoys the benefits of a wider engine. I ran the same test with FP adds and didn't notice any changes to the data above.</p><h2>Sanity Check with Linpack & Passmark</h2><p>Section by Anand Shimpi</p><p>Not completely trusting my own code, I wanted some additional data points to help understand the Swift architecture. I first turned to the iOS port of Linpack and graphed FP performance vs. problem size:</p><p align=center><a href=#><img border=0 height=384 src=https://cdn.statically.io/img/images.anandtech.com/reviews/smartphones/apple/iPhone5/review/linpack.jpg width=600 style=margin:auto;display:block;text-align:center;max-width:100%;height:auto></a></p><p>Even though I ran the benchmark for hundreds of iterations at each data point, the curves didn't come out as smooth as I would've liked them to. Regardless there's a clear trend. Swift maintains a huge performance advantage, even at small problem sizes which supports the theory of having two ports to dedicated FP hardware. There's also a much smaller relative drop in performance when going out to main memory. If you do the math on the original unscaled 4S scores you get the following data:</p><table align=center border=0 cellpadding=0 cellspacing=1 width=575><tbody readability=3><tr class=tgrey readability=2><td align=center colspan=5>Linpack Throughput: Cycles per Operation</td></tr><tr class=tlblue readability=4><td width=120>&nbsp;</td><td align=center valign=middle width=85>Apple Swift @ 1300MHz (iPhone 5)</td><td align=center valign=middle width=85>ARM Cortex A9 @ 800MHz (iPhone 4S)</td></tr><tr><td class=tlgrey>~300KB Problem Size</td><td align=center valign=middle>1.45 cycles</td><td align=center valign=middle>3.55 cycles</td></tr><tr><td class=tlgrey>~8MB Problem Size</td><td align=center valign=middle>2.08 cycles</td><td align=center valign=middle>6.75 cycles</td></tr><tr><td class=tlgrey>Increase</td><td align=center valign=middle>43%</td><td align=center valign=middle>90%</td></tr></tbody></table><p>Swift is simply able to hide memory latency better than the Cortex A9. Concurrent FP/memory operations seem to do very well on Swift...</p><p>As the last sanity check I used Passmark, another general purpose iOS microbenchmark.</p><table align=center border=0 cellpadding=0 cellspacing=1 width=575><tbody readability=4><tr class=tgrey><td align=center colspan=7>Passmark CPU Performance</td></tr><tr class=tlblue readability=8><td width=120>&nbsp;</td><td align=center valign=middle width=85>Apple A5 (2 x Cortex A9 @ 800MHz</td><td align=center valign=middle width=85>Apple A5 Scaled (2 x Cortex A9 @ 1300MHz</td><td align=center valign=middle width=85>Apple A6 (2 x Swift @ 1300MHz</td><td align=center valign=middle width=85>Swift / A9 Perf Advantage @ 1300MHz</td></tr><tr><td class=tlgrey>Integer</td><td align=center valign=middle>257</td><td align=center valign=middle>418</td><td align=center valign=middle>614</td><td align=center valign=middle>47.0%</td></tr><tr><td class=tlgrey>FP</td><td align=center valign=middle>230</td><td align=center valign=middle>374</td><td align=center valign=middle>813</td><td align=center valign=middle>118%</td></tr><tr><td class=tlgrey>Primality</td><td align=center valign=middle>54</td><td align=center valign=middle>87</td><td align=center valign=middle>183</td><td align=center valign=middle>109%</td></tr><tr><td class=tlgrey>String qsort</td><td align=center valign=middle>1065</td><td align=center valign=middle>1730</td><td align=center valign=middle>2126</td><td align=center valign=middle>22.8%</td></tr><tr><td class=tlgrey>Encryption</td><td align=center valign=middle>38.1</td><td align=center valign=middle>61.9</td><td align=center valign=middle>93.5</td><td align=center valign=middle>51.0%</td></tr><tr><td class=tlgrey>Compression</td><td align=center valign=middle>1.18</td><td align=center valign=middle>1.92</td><td align=center valign=middle>2.26</td><td align=center valign=middle>17.9%</td></tr></tbody></table><p>The integer math test uses a large dataset and performs a number of add, subtract, multiply and divide operations on the values. The dataset measures 240KB per core, which is enough to stress the L2 cache of these processors. Note the 47% increase in performance over a scaled Cortex A9.</p><p>The FP test is identical to the integer test (including size) but it works on 32 and 64-bit floating point values. The performance increase here despite facing the same workload lends credibility to the theory that there are multiple FP pipelines in Swift.</p><p>The Primality benchmark is branch heavy and features a lot of FP math and compares. Once again we see huge scaling compared to the Cortex A9.</p><p>The qsort test features integer math and is very branch heavy. The memory footprint of the test is around 5MB, but the gains here aren't as large as we've seen elsewhere. It's possible that Swift features a much larger branch mispredict penalty than the A9.</p><p>The Encryption test works on a very small dataset that can easily fit in the L1 cache but is very heavy on the math. Performance scales very well here, almost mirroring the integer benchmark results.</p><p>Finally the compression test shows us the smallest gains once you take into account Swift's higher operating frequency. There's not much more to conclude here other than we won't always see greater than generational scaling from Swift over the previous Cortex A9.</p><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmivp6x7orrAp5utnZOde6S7zGiqoaenZIN0f49oq6GdXZ69qbvNnmRuZaKaw6qx1mht</p></section></article></main></div><footer><div class=container><span class=copyright>&copy; 2024 JadeSync - <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a></span></div></footer><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/floating.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://iklan.listspress.com/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>